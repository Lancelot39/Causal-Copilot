{
  "algorithm_name": "FCI",
  "alpha": {
    "meaning": "Desired significance level in (0, 1)",
    "available_values": [0.05, 0.1, 0.01],
    "expert_suggestion": "Use 0.05 as default. Adjust based on sample size, more conservative (lower) values for larger samples. If < 500, use 0.1; Else if 500-10000 (<10000 but >500), use 0.05; Else if > 10000, using 0.01."
  },
  "indep_test": {
    "meaning": "Independence test method",
    "available_values": ["fisherz", "chisq", "kci", "fastkci", "rcit"],
    "expert_suggestion": "Use fisherz as default (for linear data). Choose based on data type, DON'T use nonlinear/non-parametric tests for linear/discrete data.\n\nLINEAR/DISCRETE (PARAMETRIC) TESTS:\n- 'fisherz': For linear continuous data (default choice for linear data)\n- 'chisq': For discrete data only (applied only for pure discrete data)\n\nNONLINEAR/NON-PARAMETRIC TESTS:\n- 'kci': For nonlinear data (very slow, use only if variable size < 10 and sample size < 1500)\n- 'rcit': Fastest approximation of kci for non-linear data (use only if variable size < 100 and sample size < 10000)\n- 'fastkci': Divide-and-conquer version of kci for non-linear data, faster than kci but less accurate (use only if variable size < 20 and sample size < 3000)\n\nFor nonlinear data, as long as variable and sample size constraints are fulfilled, choose in order of accuracy: KCI > RCIT > FastKCI."
  },
  "depth": {
    "meaning": "Maximum depth for skeleton search",
    "available_values": [-1, 6, 4, 2, 1],
    "expert_suggestion": "Use -1 as default. Use -1 for unlimited depth. For large graphs, limiting depth (e.g., 1-3) can significantly speed up the algorithm at the cost of some accuracy. A graph with node number < 10, use depth 6; A graph with node number 10 - 25, use depth 4; A graph with node number 25-50, use depth 2; A graph with node number > 50, use depth 1."
  },
  "background_knowledge": {
    "meaning": "Domain expertise constraints on causal structure",
    "available_values": [null],
    "expert_suggestion": "Use null as default when no domain knowledge is available. When user provides explicit causal constraints, the LLM will automatically format them as a JSON object with the following structure:\n\n**FORBIDDEN EDGES**: When user specifies edges that should NOT exist\n- Format: {\"forbidden_edges\": [[\"var1\", \"var2\"], [\"var3\", \"var4\"]]}\n- Example: User says 'X cannot influence Y' → {\"forbidden_edges\": [[\"X\", \"Y\"]]}\n\n**REQUIRED EDGES**: When user specifies edges that MUST exist  \n- Format: {\"required_edges\": [[\"var1\", \"var2\"], [\"var3\", \"var4\"]]}\n- Example: User says 'A must cause B' → {\"required_edges\": [[\"A\", \"B\"]]}\n\n**TIER CONSTRAINTS**: When user specifies variable ordering/hierarchy\n- Format: {\"tiers\": {\"var1\": 0, \"var2\": 1, \"var3\": 1, \"var4\": 2}}\n- Example: User says 'Genetics → Environment → Phenotype' → {\"tiers\": {\"Gene1\": 0, \"Gene2\": 0, \"Environment\": 1, \"Trait1\": 2, \"Trait2\": 2}}\n\n**MIXED CONSTRAINTS**: Combine multiple constraint types when user provides complex domain knowledge\n- Format: {\"forbidden_edges\": [...], \"required_edges\": [...], \"tiers\": {...}}\n\nIMPORTANT: FCI can handle latent confounders, so constraints should account for possible hidden variables. Only use when domain constraints are explicitly or clearly implied in user query. The LLM should extract constraint information from user input and format it as a structured JSON object."
  }
} 